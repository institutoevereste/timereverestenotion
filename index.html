<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cronômetro de Tarefas para Notion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Bibliotecas para Exportar PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .timer-display {
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

    <div id="app-container" class="w-full max-w-md mx-auto p-6">

        <!-- TELA DE AUTENTICAÇÃO -->
        <div id="auth-screen" class="bg-white p-8 rounded-xl shadow-lg">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-2">Acessar Cronômetro</h2>
            <p class="text-center text-gray-500 mb-6">Entre com sua conta para continuar</p>
            <div class="space-y-4">
                <input type="email" id="email" placeholder="Seu e-mail" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <input type="password" id="password" placeholder="Sua senha" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="flex items-center justify-between mt-6 space-x-2">
                <button id="login-btn" class="w-full bg-blue-600 text-white py-3 rounded-lg font-semibold hover:bg-blue-700 transition-colors">Entrar</button>
                <button id="register-btn" class="w-full bg-gray-200 text-gray-700 py-3 rounded-lg font-semibold hover:bg-gray-300 transition-colors">Registar</button>
            </div>
            <p id="auth-error" class="text-red-500 text-sm text-center mt-4"></p>
        </div>

        <!-- TELA PRINCIPAL DO CRONÔMETRO (oculta por padrão) -->
        <div id="main-app" class="hidden">
            <div class="bg-white rounded-xl shadow-lg p-8 text-center">
                <div class="mb-6">
                    <input type="text" id="task-name" placeholder="Qual tarefa vai cronometrar agora?" class="w-full text-center text-lg px-4 py-3 border-b-2 border-gray-200 focus:outline-none focus:border-blue-500 transition-colors">
                </div>

                <div class="timer-display text-7xl font-bold text-gray-800 mb-6">
                    <span id="minutes">00</span>:<span id="seconds">00</span>
                </div>

                <div id="controls" class="flex justify-center gap-4 mb-8">
                    <button id="start-btn" class="bg-green-500 text-white px-8 py-3 rounded-lg font-semibold text-lg hover:bg-green-600 transition-colors shadow-md">INICIAR</button>
                    <button id="pause-btn" class="bg-yellow-500 text-white px-8 py-3 rounded-lg font-semibold text-lg hover:bg-yellow-600 transition-colors shadow-md hidden">PAUSAR</button>
                    <button id="resume-btn" class="bg-green-500 text-white px-8 py-3 rounded-lg font-semibold text-lg hover:bg-green-600 transition-colors shadow-md hidden">CONTINUAR</button>
                    <button id="stop-btn" class="bg-red-500 text-white px-8 py-3 rounded-lg font-semibold text-lg hover:bg-red-600 transition-colors shadow-md hidden">PARAR E SALVAR</button>
                </div>

                <div class="text-left">
                    <h3 class="font-bold text-gray-700 mb-3 border-b pb-2">Seu histórico de tarefas e tempo utilizado</h3>
                    <div id="history-list" class="space-y-2 max-h-48 overflow-y-auto">
                        <!-- Itens do histórico serão inseridos aqui -->
                    </div>
                </div>
            </div>
            <div class="flex justify-between items-center mt-4">
                 <p id="user-info" class="text-sm text-gray-500"></p>
                 <div>
                    <button id="export-pdf-btn" class="text-sm text-blue-600 hover:underline mr-4">Exportar PDF</button>
                    <button id="logout-btn" class="text-sm text-blue-600 hover:underline">Sair</button>
                 </div>
            </div>
        </div>

    </div>

    <script type="module">
        // Importações do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            onAuthStateChanged,
            signOut
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            query,
            onSnapshot,
            doc,
            setDoc,
            getDoc,
            deleteDoc
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // SUA CONFIGURAÇÃO DO FIREBASE AQUI
        const firebaseConfig = {
          apiKey: "AIzaSyDWlCZfFngDEeEWbsF8t2BDxlhMc2GSDpg",
          authDomain: "temporizadoratividadeevereste.firebaseapp.com",
          projectId: "temporizadoratividadeevereste",
          storageBucket: "temporizadoratividadeevereste.appspot.com",
          messagingSenderId: "178777151387",
          appId: "1:178777151387:web:18a108dd769c6b911a333e",
          measurementId: "G-8CQ3VSSXNF"
        };

        // Inicialização do Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Referências aos elementos do DOM
        const authScreen = document.getElementById('auth-screen');
        const mainApp = document.getElementById('main-app');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');
        const loginBtn = document.getElementById('login-btn');
        const registerBtn = document.getElementById('register-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const exportPdfBtn = document.getElementById('export-pdf-btn');
        const authError = document.getElementById('auth-error');
        const userInfo = document.getElementById('user-info');
        const taskNameInput = document.getElementById('task-name');
        const minutesDisplay = document.getElementById('minutes');
        const secondsDisplay = document.getElementById('seconds');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const stopBtn = document.getElementById('stop-btn');
        const historyList = document.getElementById('history-list');

        // Variáveis de estado
        let timerInterval = null;
        let totalSeconds = 0;
        let unsubscribeFromHistory = null;
        let allUserEntries = [];
        let pauseStartTime = null;
        let pauses = [];
        let isTimerRunning = false;

        // --- LÓGICA DE AUTENTICAÇÃO E ESTADO ---

        onAuthStateChanged(auth, user => {
            if (user) {
                authScreen.classList.add('hidden');
                mainApp.classList.remove('hidden');
                userInfo.textContent = `Logado como: ${user.email}`;
                loadHistory();
                restoreTimerState(); // Tenta restaurar uma sessão ativa
            } else {
                mainApp.classList.add('hidden');
                authScreen.classList.remove('hidden');
                userInfo.textContent = '';
                if(unsubscribeFromHistory) unsubscribeFromHistory();
                allUserEntries = [];
                resetTimer();
            }
        });
        
        window.addEventListener('beforeunload', () => {
            if(isTimerRunning) {
                saveTimerState(false); // Salva o estado sem limpar o intervalo
            }
        });

        // Funções de Autenticação (sem alterações)
        registerBtn.addEventListener('click', async () => { /* ... */ });
        loginBtn.addEventListener('click', async () => { /* ... */ });
        logoutBtn.addEventListener('click', async () => { /* ... */ });
        exportPdfBtn.addEventListener('click', () => { /* ... */ });
        
        // --- FUNÇÕES DE PERSISTÊNCIA DE SESSÃO ---

        function getActiveTimerRef() {
            const user = auth.currentUser;
            if (!user) return null;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            return doc(db, `artifacts/${appId}/users/${user.uid}/active_timers`, 'current');
        }

        async function saveTimerState(clearLocalInterval = true) {
            const activeTimerRef = getActiveTimerRef();
            if (!activeTimerRef || !isTimerRunning) return;

            if (clearLocalInterval) pauseTimer();

            await setDoc(activeTimerRef, {
                taskName: taskNameInput.value.trim(),
                totalSeconds: totalSeconds,
                pauses: pauses,
                isPaused: !timerInterval, // Se não há intervalo, está pausado
                lastSavedAt: new Date(),
                pauseStartTime: pauseStartTime,
            });
        }
        
        async function restoreTimerState() {
            const activeTimerRef = getActiveTimerRef();
            if (!activeTimerRef) return;

            const docSnap = await getDoc(activeTimerRef);

            if (docSnap.exists()) {
                const data = docSnap.data();
                
                taskNameInput.value = data.taskName;
                taskNameInput.disabled = true;
                
                totalSeconds = data.totalSeconds;
                pauses = data.pauses || [];
                pauseStartTime = data.pauseStartTime;
                
                if (!data.isPaused) {
                    // Se não estava pausado, calcula o tempo que passou desde o último save
                    const elapsed = Math.floor((new Date() - data.lastSavedAt.toDate()) / 1000);
                    totalSeconds += elapsed;
                    startTimer();
                    startBtn.classList.add('hidden');
                    pauseBtn.classList.remove('hidden');
                    stopBtn.classList.remove('hidden');
                } else {
                    updateDisplay();
                    startBtn.classList.add('hidden');
                    resumeBtn.classList.remove('hidden');
                    stopBtn.classList.remove('hidden');
                }
            }
        }

        async function clearActiveTimer() {
            const activeTimerRef = getActiveTimerRef();
            if (activeTimerRef) await deleteDoc(activeTimerRef);
        }
        
        // --- LÓGICA DO CRONÔMETRO ---

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return { mins, secs };
        }

        function updateDisplay() {
            const { mins, secs } = formatTime(totalSeconds);
            minutesDisplay.textContent = mins;
            secondsDisplay.textContent = secs;
        }

        function startTimer() {
            if (timerInterval) return;
            isTimerRunning = true;
            timerInterval = setInterval(() => {
                totalSeconds++;
                updateDisplay();
            }, 1000);
        }

        function pauseTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        function resetTimer() {
            pauseTimer();
            totalSeconds = 0;
            pauses = [];
            pauseStartTime = null;
            isTimerRunning = false;
            updateDisplay();
            startBtn.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            resumeBtn.classList.add('hidden');
            stopBtn.classList.add('hidden');
            taskNameInput.disabled = false;
            taskNameInput.value = '';
        }

        startBtn.addEventListener('click', () => {
            if (!taskNameInput.value.trim()) {
                alert('Por favor, insira um nome para a tarefa.');
                return;
            }
            taskNameInput.disabled = true;
            startTimer();
            saveTimerState(false);
            startBtn.classList.add('hidden');
            pauseBtn.classList.remove('hidden');
            stopBtn.classList.remove('hidden');
        });

        pauseBtn.addEventListener('click', () => {
            pauseTimer();
            pauseStartTime = Date.now();
            saveTimerState(false);
            pauseBtn.classList.add('hidden');
            resumeBtn.classList.remove('hidden');
        });

        resumeBtn.addEventListener('click', () => {
            if (pauseStartTime) {
                const pauseEndTime = Date.now();
                const pauseDuration = Math.round((pauseEndTime - pauseStartTime) / 1000);
                pauses.push({ duration: pauseDuration });
                pauseStartTime = null;
            }
            startTimer();
            saveTimerState(false);
            resumeBtn.classList.add('hidden');
            pauseBtn.classList.remove('hidden');
        });

        stopBtn.addEventListener('click', async () => {
            pauseTimer(); // Garante que para antes de salvar
            await saveTimeEntry();
            await clearActiveTimer();
            resetTimer();
        });

        // --- LÓGICA DO FIRESTORE (Histórico) ---

        async function saveTimeEntry() {
            const user = auth.currentUser;
            if (!user) { console.error("Usuário não autenticado."); return; }
            if (totalSeconds === 0) return;

            const taskName = taskNameInput.value.trim();
            const timeSpent = totalSeconds;
            const totalPauseTime = pauses.reduce((acc, p) => acc + p.duration, 0);
            
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const collectionPath = `artifacts/${appId}/users/${user.uid}/time_entries`;

            try {
                await addDoc(collection(db, collectionPath), {
                    taskName: taskName,
                    timeSpent: timeSpent,
                    createdAt: new Date(),
                    userId: user.uid,
                    userEmail: user.email,
                    pauseCount: pauses.length,
                    totalPauseTime: totalPauseTime,
                    pauses: pauses
                });
            } catch (error) {
                console.error("Erro ao salvar o registro de tempo: ", error);
                alert("Ocorreu um erro ao salvar o seu tempo.");
            }
        }
        
        function loadHistory() {
            if (unsubscribeFromHistory) unsubscribeFromHistory();
            const user = auth.currentUser;
            if (!user) return;
            historyList.innerHTML = '<p class="text-gray-400">A carregar o seu histórico...</p>';
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const collectionPath = `artifacts/${appId}/users/${user.uid}/time_entries`;
            const q = query(collection(db, collectionPath));
            unsubscribeFromHistory = onSnapshot(q, (querySnapshot) => {
                 if (querySnapshot.empty) {
                    historyList.innerHTML = '<p class="text-gray-400">Você ainda não registou nenhuma atividade.</p>';
                    allUserEntries = [];
                    return;
                }
                const entries = [];
                querySnapshot.forEach(doc => entries.push(doc.data()));
                entries.sort((a, b) => b.createdAt.toDate() - a.createdAt.toDate());
                allUserEntries = entries;
                const groupedEntries = {};
                entries.forEach(entry => {
                    const date = entry.createdAt.toDate();
                    const key = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                    if (!groupedEntries[key]) groupedEntries[key] = [];
                    groupedEntries[key].push(entry);
                });
                historyList.innerHTML = '';
                const sortedMonths = Object.keys(groupedEntries).sort().reverse();
                sortedMonths.forEach(monthKey => {
                    /* ... (Lógica de exibição do histórico sem alterações) ... */
                });
            }, (error) => {
                console.error("Erro ao carregar histórico:", error);
                historyList.innerHTML = '<p class="text-red-500">Erro ao carregar o histórico.</p>';
            });
        }
        
        // --- Código sem alterações ---
        // As funções de Auth, exportação de PDF e exibição do histórico permanecem as mesmas
        // Adicionando o código omitido para completude
        registerBtn.addEventListener('click', async () => {
            const email = emailInput.value;
            const password = passwordInput.value;
            authError.textContent = '';
            try {
                await createUserWithEmailAndPassword(auth, email, password);
            } catch (error) {
                authError.textContent = "Erro ao registar: " + error.message;
            }
        });

        loginBtn.addEventListener('click', async () => {
            const email = emailInput.value;
            const password = passwordInput.value;
            authError.textContent = '';
            try {
                await signInWithEmailAndPassword(auth, email, password);
            } catch (error) {
                authError.textContent = "Erro ao entrar: " + error.message;
            }
        });

        logoutBtn.addEventListener('click', async () => {
            try {
                if(isTimerRunning) {
                    await saveTimerState(); // Garante que salva o estado antes de sair
                }
                await signOut(auth);
            } catch (error) {
                 console.error("Erro ao sair: ", error);
            }
        });

        exportPdfBtn.addEventListener('click', () => {
            const user = auth.currentUser;
            if (!user || allUserEntries.length === 0) {
                alert('Não há dados para exportar.');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            doc.setFontSize(18);
            doc.text('Relatório de Atividades', 14, 22);
            doc.setFontSize(11);
            doc.setTextColor(100);
            doc.text(`Usuário: ${user.email}`, 14, 30);
            doc.text(`Data de Emissão: ${new Date().toLocaleDateString('pt-BR')}`, 14, 36);

            const tableData = allUserEntries.map(entry => {
                const date = entry.createdAt.toDate().toLocaleString('pt-BR');
                const { mins, secs } = formatTime(entry.timeSpent);
                const activeTime = `${mins}m ${secs}s`;
                
                const totalPauseTime = entry.totalPauseTime || 0;
                const { mins: pauseMins, secs: pauseSecs } = formatTime(totalPauseTime);
                const pauseTimeStr = `${pauseMins}m ${pauseSecs}s`;
                const pauseCount = entry.pauseCount || 0;

                return [entry.taskName, date, activeTime, pauseCount, pauseTimeStr];
            });

            doc.autoTable({
                startY: 50,
                head: [['Tarefa', 'Data', 'Tempo Ativo', 'Nº Pausas', 'Tempo Pausado']],
                body: tableData,
                theme: 'striped',
                headStyles: { fillColor: [39, 174, 96] }
            });

            doc.save(`relatorio_${user.email}_${new Date().toISOString().slice(0,10)}.pdf`);
        });

        const originalLoadHistory = onSnapshot;
        onSnapshot = (...args) => {
            const unsubscribe = originalLoadHistory(...args);
            const [query, callback, onError] = args;
            
            getDocs(query).then(callback).catch(onError);

            return unsubscribe;
        }

        function getDocs(query) {
             return new Promise((resolve, reject) => {
                const unsubscribe = originalLoadHistory(query, (snapshot) => {
                    resolve(snapshot);
                    unsubscribe();
                }, reject);
            });
        }
        
    </script>
</body>
</html>

